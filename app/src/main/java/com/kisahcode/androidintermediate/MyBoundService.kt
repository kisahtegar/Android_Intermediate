package com.kisahcode.androidintermediate

import android.app.Service
import android.content.Intent
import android.os.Binder
import android.os.IBinder
import android.util.Log
import androidx.lifecycle.MutableLiveData
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

/**
 * A bound service that provides a live data stream of numbers.
 *
 * This service generates a stream of numbers in a coroutine and updates a LiveData object with the
 * latest number. Clients can bind to this service to receive updates on the number stream.
 */
class MyBoundService : Service() {

    // Binder instance to allow clients to interact with the service.
    private var binder = MyBinder()

    // Coroutine job and scope for background tasks.
    private val serviceJob = Job()
    private val serviceScope = CoroutineScope(Dispatchers.Main + serviceJob)

    // LiveData object to hold the latest number generated by the service.
    val numberLiveData: MutableLiveData<Int> = MutableLiveData()

    /**
     * Called by the system when a client binds to the service.
     *
     * This method starts a coroutine to generate a stream of numbers and updates the LiveData object
     * with the latest number. The coroutine runs until it is canceled or the service is unbound.
     *
     * @param intent The Intent that was used to bind to this service.
     * @return An IBinder object that clients can use to interact with the service.
     */
    override fun onBind(intent: Intent): IBinder {
        Log.d(TAG, "onBind: ")

        // Start a coroutine to generate a stream of numbers.
        serviceScope.launch {
            for (i in 1..50) {
                delay(1000)
                Log.d(TAG, "Do Something $i")
                // Update the LiveData object with the latest number.
                numberLiveData.postValue(i)
            }
            Log.d(TAG, "Service dihentikan")
        }

        // Return the binder for clients to interact with the service.
        return binder
    }

    /**
     * Called when the service is being destroyed.
     */
    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy: ")
    }

    /**
     * Called when a client unbinds from the service.
     *
     * This method cancels the coroutine job to stop generating numbers when the service is no longer
     * bound to any client.
     *
     * @param intent The Intent that was used to unbind from the service.
     * @return True if the service should remain running, false otherwise.
     */
    override fun onUnbind(intent: Intent?): Boolean {
        Log.d(TAG, "onUnbind: ")
        // Cancel the coroutine job to stop generating numbers.
        serviceJob.cancel()
        return super.onUnbind(intent)
    }

    /**
     * Called when a client rebinds to the service after onUnbind() has been called.
     *
     * @param intent The Intent that was used to rebind to the service.
     */
    override fun onRebind(intent: Intent?) {
        super.onRebind(intent)
        Log.d(TAG, "onRebind: ")
    }

    /**
     * Inner class representing the binder for this service.
     *
     * Clients can use this binder to obtain an instance of the MyBoundService class and access its
     * public methods and properties.
     */
    internal inner class MyBinder : Binder() {
        val getService: MyBoundService = this@MyBoundService
    }

    companion object {
        private val TAG = MyBoundService::class.java.simpleName
    }
}